## 3.3.1 呜呜呜，为什么最短路那么难，最小树却这么简单，好吧 ，其实题目叫做 最小生成树📕

*2025年5月25日*

#### Prim求最短路

- **一般用于稠密图求最小生成树**

- **时间为O(n^2)**

- **可用堆优化，生成堆优化的Prim；但是一般在稀疏图的情况下，用Kruskal算法更优**

  ##### 算法过程

  1.随机找到一个点（一般为点1），将其距离定义为0，其他点的距离定义为正无穷（**与Dijkstra不同的是:dist数组表示的是当前点距离最小生成树集合的距离,并不是距离源点的距离**）

  2.**迭代n次（因为有n个点所以是n次，Dijkstra为n - 1次）， 每次找到距离集合最近的点，归入集合，并更新dist**

##### 与 Dijkstra 算法对比

- **目标差异**：Dijkstra 算法旨在求源点到其他各点的最短路径；Prim 算法目标是求无向连通图的最小生成树。
- **迭代次数差异**：Dijkstra 算法迭代 n - 1 次，是因为确定了源点后，后续每次迭代确定一个新顶点的最短路径，n 个顶点只需 n - 1 次就能确定除源点外其他顶点到源点的最短路径；Prim 算法迭代 n 次，是要将 n 个顶点都纳入最小生成树集合。
- **距离含义差异**：Dijkstra 算法中`dist`数组记录的是顶点到源点的距离；Prim 算法中`dist`数组记录的是顶点到当前最小生成树集合的距离。

**代码：**

```c++
const int N = 510;
int g[N][N], dist[N];
bool st[N];
int n, m;

int prim() {
	memset(dist, 0x3f, sizeof dist);
	dist[1] = 0;
	int res = 0;
	for (int i = 0; i < n; i++) {
		int t = -1;
		for (int j = 1; j <= n; j++)
			if (!st[j] && (t == -1 || dist[t] > dist[j]))
				t = j;		
		if (i && dist[t] == 0x3f3f3f3f) return 0x3f3f3f3f; // 判断树是否连通
		if (i) 	res += dist[t];	
		st[t] = true;
		for (int j = 1; j <= n; j++)
			dist[j] = min(dist[j], g[t][j]);
	}
	return res;
}
```

**测试数据**

```pascal
4 5
1 2 1
1 3 2
1 4 3
2 3 2
3 4 4

6
```

#### Kruskal求最短路（克鲁斯卡）

- **一般适用于稀疏图**
- **稀疏图中时间为O(mlogm), 时间由排序主导**
- **利用了并查集**

#### 算法过程

1.将每个边储存在结构体里，并用sort排序

2.利用并查集（1.判断是否同一父节点，2.连接），将边由小到大依次连接

##### 代码：

```	c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1e5 + 10;
int n, m;
int p[N];
struct Edge {
	int a, b, w;
	bool operator< (const Edge &W) const {
		return w < W.w;
	}
}edges[N];

int find(int x) {
	if (p[x] != x) p[x] = find(p[x]);
	return p[x];
}

int main() {
	cin >> n >> m;
	for (int i = 0; i < m ;i++) {
		int a, b, c;
		cin >> a >> b >> c;
		edges[i] = {a, b, c};
	}
	for (int i = 1; i <= n; i++) p[i] = i;
	sort(edges, edges + m);
	int res = 0, t = 0;
	for (int i = 0; i < m; i++) {
		int a = edges[i].a, b = edges[i].b, w = edges[i].w;
		if (find(a) != find(b)) {
			p[find(a)] = find(b);
			res += w;
			t += 1;
		} 
	}
	if (t < n - 1)	puts("impossible");
	cout << res << endl;
	return 0;
}
```

#### 染色法求二分图

总之就是用DFS遍历涂色

```c++
#include <iostream>
#include <cstring>

using namespace std;

const int N = 1e5 + 10;
int idx, ne[N], e[N], h[N];
int n, m;
int colour[N];

void add(int a, int b) {
	e[++idx] = b, ne[idx] = h[a], h[a] = idx;
}

bool dfs(int u, int c) {
	colour[u] = c;
	for (int i = h[u]; i != -1; i = ne[i]) {
		int j = e[i];
		if (!colour[j]) {
			if (!dfs(j, 3 - c)) return false;
		}
		else if (colour[j] == c) return false;
	}
	return true;
}
int main() {
	cin >> n >> m;
	memset(h, -1, sizeof h);
	while (m--) {
		int a, b;
		cin >> a >> b;
		add(a, b), add(b, a);
	}
	bool flag = true;
	for (int i = 1; i <= n; i++) {
		if (!colour[i]) {
			if (!dfs(i, 1)) {
				flag = false;
				break;
			}
		}
	}
	if (flag) puts("YES");
	else puts("NO");
	return 0;
}
```

**测试数据**

```pascal
4 4
1 3
2 3
1 4
2 4

YES
```

#### 匈牙利算法

**具体情况我现在还解释不出来，具体看代码吧！**

```c++
#include <iostream>
#include <cstring>

using namespace std;

const int N = 1e5 + 10;
int idx, ne[N], e[N], h[N];
int match[N];
bool st[N];
int n1, n2, m;

void add(int a, int b) {
	e[++idx] = b, ne[idx] = h[a], h[a] =idx;
}

bool find(int u) {
	for (int i = h[u]; i != -1; i = ne[i]) {
		int j = e[i];
		if (!st[j]) {
			st[j] = true;
			if (match[j] == 0 || find(match[j])) {
				match[j] = u;
				return true;
			}
		}
	}
	return false;
}
int main() {
	cin >> n1 >> n2 >> m;
	memset(h, -1, sizeof h);
	while (m--) {
		int a, b;
		cin >> a >> b;
		add(a, b);
	}
	int res = 0;
	for (int i = 1; i <= n1; i++) {
		memset(st, false, sizeof st);
		if (find(i)) res += 1;
	}
	cout << res << endl;
	return 0;
}
```

