## 3.3.1 å‘œå‘œå‘œï¼Œä¸ºä»€ä¹ˆæœ€çŸ­è·¯é‚£ä¹ˆéš¾ï¼Œæœ€å°æ ‘å´è¿™ä¹ˆç®€å•ï¼Œå¥½å§ ï¼Œå…¶å®é¢˜ç›®å«åš æœ€å°ç”Ÿæˆæ ‘ğŸ“•

*2025å¹´5æœˆ25æ—¥*

#### Primæ±‚æœ€çŸ­è·¯

- **ä¸€èˆ¬ç”¨äºç¨ å¯†å›¾æ±‚æœ€å°ç”Ÿæˆæ ‘**

- **æ—¶é—´ä¸ºO(n^2)**

- **å¯ç”¨å †ä¼˜åŒ–ï¼Œç”Ÿæˆå †ä¼˜åŒ–çš„Primï¼›ä½†æ˜¯ä¸€èˆ¬åœ¨ç¨€ç–å›¾çš„æƒ…å†µä¸‹ï¼Œç”¨Kruskalç®—æ³•æ›´ä¼˜**

  ##### ç®—æ³•è¿‡ç¨‹

  1.éšæœºæ‰¾åˆ°ä¸€ä¸ªç‚¹ï¼ˆä¸€èˆ¬ä¸ºç‚¹1ï¼‰ï¼Œå°†å…¶è·ç¦»å®šä¹‰ä¸º0ï¼Œå…¶ä»–ç‚¹çš„è·ç¦»å®šä¹‰ä¸ºæ­£æ— ç©·ï¼ˆ**ä¸Dijkstraä¸åŒçš„æ˜¯:distæ•°ç»„è¡¨ç¤ºçš„æ˜¯å½“å‰ç‚¹è·ç¦»æœ€å°ç”Ÿæˆæ ‘é›†åˆçš„è·ç¦»,å¹¶ä¸æ˜¯è·ç¦»æºç‚¹çš„è·ç¦»**ï¼‰

  2.**è¿­ä»£næ¬¡ï¼ˆå› ä¸ºæœ‰nä¸ªç‚¹æ‰€ä»¥æ˜¯næ¬¡ï¼ŒDijkstraä¸ºn - 1æ¬¡ï¼‰ï¼Œ æ¯æ¬¡æ‰¾åˆ°è·ç¦»é›†åˆæœ€è¿‘çš„ç‚¹ï¼Œå½’å…¥é›†åˆï¼Œå¹¶æ›´æ–°dist**

##### ä¸ Dijkstra ç®—æ³•å¯¹æ¯”

- **ç›®æ ‡å·®å¼‚**ï¼šDijkstra ç®—æ³•æ—¨åœ¨æ±‚æºç‚¹åˆ°å…¶ä»–å„ç‚¹çš„æœ€çŸ­è·¯å¾„ï¼›Prim ç®—æ³•ç›®æ ‡æ˜¯æ±‚æ— å‘è¿é€šå›¾çš„æœ€å°ç”Ÿæˆæ ‘ã€‚
- **è¿­ä»£æ¬¡æ•°å·®å¼‚**ï¼šDijkstra ç®—æ³•è¿­ä»£ n - 1 æ¬¡ï¼Œæ˜¯å› ä¸ºç¡®å®šäº†æºç‚¹åï¼Œåç»­æ¯æ¬¡è¿­ä»£ç¡®å®šä¸€ä¸ªæ–°é¡¶ç‚¹çš„æœ€çŸ­è·¯å¾„ï¼Œn ä¸ªé¡¶ç‚¹åªéœ€ n - 1 æ¬¡å°±èƒ½ç¡®å®šé™¤æºç‚¹å¤–å…¶ä»–é¡¶ç‚¹åˆ°æºç‚¹çš„æœ€çŸ­è·¯å¾„ï¼›Prim ç®—æ³•è¿­ä»£ n æ¬¡ï¼Œæ˜¯è¦å°† n ä¸ªé¡¶ç‚¹éƒ½çº³å…¥æœ€å°ç”Ÿæˆæ ‘é›†åˆã€‚
- **è·ç¦»å«ä¹‰å·®å¼‚**ï¼šDijkstra ç®—æ³•ä¸­`dist`æ•°ç»„è®°å½•çš„æ˜¯é¡¶ç‚¹åˆ°æºç‚¹çš„è·ç¦»ï¼›Prim ç®—æ³•ä¸­`dist`æ•°ç»„è®°å½•çš„æ˜¯é¡¶ç‚¹åˆ°å½“å‰æœ€å°ç”Ÿæˆæ ‘é›†åˆçš„è·ç¦»ã€‚

**ä»£ç ï¼š**

```c++
const int N = 510;
int g[N][N], dist[N];
bool st[N];
int n, m;

int prim() {
	memset(dist, 0x3f, sizeof dist);
	dist[1] = 0;
	int res = 0;
	for (int i = 0; i < n; i++) {
		int t = -1;
		for (int j = 1; j <= n; j++)
			if (!st[j] && (t == -1 || dist[t] > dist[j]))
				t = j;		
		if (i && dist[t] == 0x3f3f3f3f) return 0x3f3f3f3f; // åˆ¤æ–­æ ‘æ˜¯å¦è¿é€š
		if (i) 	res += dist[t];	
		st[t] = true;
		for (int j = 1; j <= n; j++)
			dist[j] = min(dist[j], g[t][j]);
	}
	return res;
}
```

**æµ‹è¯•æ•°æ®**

```pascal
4 5
1 2 1
1 3 2
1 4 3
2 3 2
3 4 4

6
```

#### Kruskalæ±‚æœ€çŸ­è·¯ï¼ˆå…‹é²æ–¯å¡ï¼‰

- **ä¸€èˆ¬é€‚ç”¨äºç¨€ç–å›¾**
- **ç¨€ç–å›¾ä¸­æ—¶é—´ä¸ºO(mlogm), æ—¶é—´ç”±æ’åºä¸»å¯¼**
- **åˆ©ç”¨äº†å¹¶æŸ¥é›†**

#### ç®—æ³•è¿‡ç¨‹

1.å°†æ¯ä¸ªè¾¹å‚¨å­˜åœ¨ç»“æ„ä½“é‡Œï¼Œå¹¶ç”¨sortæ’åº

2.åˆ©ç”¨å¹¶æŸ¥é›†ï¼ˆ1.åˆ¤æ–­æ˜¯å¦åŒä¸€çˆ¶èŠ‚ç‚¹ï¼Œ2.è¿æ¥ï¼‰ï¼Œå°†è¾¹ç”±å°åˆ°å¤§ä¾æ¬¡è¿æ¥

##### ä»£ç ï¼š

```	c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1e5 + 10;
int n, m;
int p[N];
struct Edge {
	int a, b, w;
	bool operator< (const Edge &W) const {
		return w < W.w;
	}
}edges[N];

int find(int x) {
	if (p[x] != x) p[x] = find(p[x]);
	return p[x];
}

int main() {
	cin >> n >> m;
	for (int i = 0; i < m ;i++) {
		int a, b, c;
		cin >> a >> b >> c;
		edges[i] = {a, b, c};
	}
	for (int i = 1; i <= n; i++) p[i] = i;
	sort(edges, edges + m);
	int res = 0, t = 0;
	for (int i = 0; i < m; i++) {
		int a = edges[i].a, b = edges[i].b, w = edges[i].w;
		if (find(a) != find(b)) {
			p[find(a)] = find(b);
			res += w;
			t += 1;
		} 
	}
	if (t < n - 1)	puts("impossible");
	cout << res << endl;
	return 0;
}
```

#### æŸ“è‰²æ³•æ±‚äºŒåˆ†å›¾

æ€»ä¹‹å°±æ˜¯ç”¨DFSéå†æ¶‚è‰²

```c++
#include <iostream>
#include <cstring>

using namespace std;

const int N = 1e5 + 10;
int idx, ne[N], e[N], h[N];
int n, m;
int colour[N];

void add(int a, int b) {
	e[++idx] = b, ne[idx] = h[a], h[a] = idx;
}

bool dfs(int u, int c) {
	colour[u] = c;
	for (int i = h[u]; i != -1; i = ne[i]) {
		int j = e[i];
		if (!colour[j]) {
			if (!dfs(j, 3 - c)) return false;
		}
		else if (colour[j] == c) return false;
	}
	return true;
}
int main() {
	cin >> n >> m;
	memset(h, -1, sizeof h);
	while (m--) {
		int a, b;
		cin >> a >> b;
		add(a, b), add(b, a);
	}
	bool flag = true;
	for (int i = 1; i <= n; i++) {
		if (!colour[i]) {
			if (!dfs(i, 1)) {
				flag = false;
				break;
			}
		}
	}
	if (flag) puts("YES");
	else puts("NO");
	return 0;
}
```

**æµ‹è¯•æ•°æ®**

```pascal
4 4
1 3
2 3
1 4
2 4

YES
```

#### åŒˆç‰™åˆ©ç®—æ³•

**å…·ä½“æƒ…å†µæˆ‘ç°åœ¨è¿˜è§£é‡Šä¸å‡ºæ¥ï¼Œå…·ä½“çœ‹ä»£ç å§ï¼**

```c++
#include <iostream>
#include <cstring>

using namespace std;

const int N = 1e5 + 10;
int idx, ne[N], e[N], h[N];
int match[N];
bool st[N];
int n1, n2, m;

void add(int a, int b) {
	e[++idx] = b, ne[idx] = h[a], h[a] =idx;
}

bool find(int u) {
	for (int i = h[u]; i != -1; i = ne[i]) {
		int j = e[i];
		if (!st[j]) {
			st[j] = true;
			if (match[j] == 0 || find(match[j])) {
				match[j] = u;
				return true;
			}
		}
	}
	return false;
}
int main() {
	cin >> n1 >> n2 >> m;
	memset(h, -1, sizeof h);
	while (m--) {
		int a, b;
		cin >> a >> b;
		add(a, b);
	}
	int res = 0;
	for (int i = 1; i <= n1; i++) {
		memset(st, false, sizeof st);
		if (find(i)) res += 1;
	}
	cout << res << endl;
	return 0;
}
```

