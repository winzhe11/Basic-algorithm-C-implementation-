## 3.2.1 呜呜！！ 最短路太难了

*5月20日*

![](./../photo/最短路.png)

#### 啊！你说的都对，但如何处理自环和 重边现象

邻接表不用考虑重边

```c++
int a, b, c;
cin >> a >> b >> c;
if (a == b) continue;
g[a][b] = g[b][a] = min(g[a][b], c);
或
for (int i = 1; i <= n; i++) g[i][i] = 0;     
```

#### 稀疏图和稠密图中边长m和节点n的关系

- **稀疏图**：边数 m 远小于节点数 n 的平方，即$(m \ll n^2)$，一般常见的情况是 m 与 n 同数量级或 m 略大于 n，如\(m = O(n)\)或\(m = O(n \log n)\)等。
- **稠密图**：边数 m 接近或等于节点数 n 的平方，即$(m \approx n^2)$，极端情况下，完全图的边数$(m=\frac{n(n - 1)}{2})$，属于典型的稠密图。

#### Dijksra快乐！！！（狄杰斯特拉）

- **对于稠密图我们一般选择dijkstra朴素算法**
- **dijkstra算法不能用于解决有负权边的情况**
- **时间复杂度为O(n^2)**

##### 算法过程

1. 将第一个点的距离定义为0（基于贪心），即**dist[1] = 0**,其他点的距离为**正无穷**；

2. **设有一集合S(点1在这个集合)， 每次从集合外找出距离自己最短的一个点j，将它加入这个集合（所以共迭代n - 1次 与prim算法不同）**；

3. **松弛操作：用点 j 来更新其他点到源点（点1）的距离（若存在边 \(j \to k\)，且 `dist[j] + weight(j,k) < dist[k]`，则更新 `dist[k] = dist[j] + weight(j,k)`。）**；

   

##### 代码实现

```c++
// 朴素 Dijkstra
#include <iostream>
#include <cstring>

using namespace std;

const int N = 510;
int g[N][N], dist[N]; // dist数组表示该点距离源点的距离
int n, m;
bool st[N]; // 记录该点是否在集合中

int dijkstra() {
	memset(dist, 0x3f, sizeof dist); // 初始化所有点距离源点为正无穷
	dist[1] = 0;
	for (int i = 1; i < n; i++) { // 迭代n - 1 次
		int t = -1;
		for (int j = 1; j <= n; j++)
			if (!st[j] && (t == -1 || dist[t] > dist[j])) // 找出距离最近的点
				t = j;
		st[t] = true;
		for (int j = 1; j <= n; j++)
			dist[j] = min(dist[j], dist[t] + g[t][j]);	// 更新距离
	}
	return dist[n];
}
int main() {
	cin >> n >> m;
	memset(g, 0x3f, sizeof g);
	// for (int i = 1; i <= n; i++) g[i][i] = 0; // 此处处理自环可省略，该步骤在更新距离中有体现
	while (m--) {
		int a, b, c;
		cin >> a >> b >> c;
		g[a][b] = min(g[a][b], c); // 处理重边
	}
	cout << dijkstra() << endl;
	return 0;
}
```

代码中也可加入

```c++
if (t == n) break; // 此时答案已找到
```



#### 堆优化Dijkstra

**当为稀疏图（n<<m）时，用堆优化**

```c++
#include <iostream>
#include <cstring>
#include <vector>
#include <queue>
#include <utility>

using namespace std;

const int N = 1e5 + 10;
typedef pair<int, int> PII;
int idx, ne[N], e[N], h[N], w[N];
int n, m;
int dist[N];
bool st[N]; // 存储每个点的最短距离是否已确定
priority_queue <PII, vector <PII>, greater <PII>> heap;

void add(int a, int b, int c) {
	e[++idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx;
}

int dijkstra() {
	memset(dist, 0x3f, sizeof dist);
	dist[1] = 0;
	heap.emplace(0, 1);    // first存储距离，second存储节点编号
	while (heap.size()) {
		auto t = heap.top();
		heap.pop();
		int distance = t.first, index = t.second;
		if (st[index]) continue; // 可处理重边
		st[index] = true;
		for (int i = h[index]; i != -1; i = ne[i]) {
			int j = e[i];
			if (dist[j] > distance + w[i]) { // 松弛
				dist[j] = distance + w[i];
				heap.emplace(dist[j], j);
			}
		}
	}
	return dist[n];
}
int main() {
	cin >> n >> m;
	memset(h, -1, sizeof h);
	while (m--) {
		int a, b, c;
		cin >> a >> b >> c;
		add(a, b, c);
	}
	cout << dijkstra() << endl;
	return 0;
}
```

**时间复杂度分析：每次出队为log n, 共n次，则为nlog n,共松弛m次，每次松弛导致一次入队，所以mlog n, 时间复杂度为（m + n）log n, 又因为 n << m, 所以时间复杂度为O(mlog n).**

#### Bellman_ford

- **负权边用Bellman_ford**
- **时间复杂度为O(nm)，下方SPFA为优化的bellman_ford, 时间更快**
- **可判断是否有负权环**

**算法过程**

1.迭代n - 1 次；

2.枚举每个边，进行松弛操作；

**为什么要迭代？**

因为枚举每个边时，边是乱序的，所以你无法确定该点是否已经得到了答案，所以要松弛整个图n - 1次；

```c++
int n, m;       // n表示点数，m表示边数
int dist[N];        // dist[x]存储1到x的最短路距离

struct Edge     // 边，a表示出点，b表示入点，w表示边的权重
{
    int a, b, w;
}edges[M];

// 求1到n的最短路距离，如果无法从1走到n，则返回-1。
int bellman_ford()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    // 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。
    for (int i = 0; i < n; i ++ )
    {
        for (int j = 0; j < m; j ++ )
        {
            int a = edges[j].a, b = edges[j].b, w = edges[j].w;
            if (dist[b] > dist[a] + w)
                dist[b] = dist[a] + w;
        }
    }

    if (dist[n] > 0x3f3f3f3f / 2) return -1;
    return dist[n];
}
```

**此处多迭代一次是为了判断是否存在负权环**

#### SPFA算法

- **基于队列和BFS的优化， SPFA只讲每次松弛过的,距离会变的点入队，时间复杂度大幅度降低**
- **时间复杂度一般为O(kn), 最长为O(mn)**
- **时间复杂度的k代表的是图中树的层数， 所以当只有一个枝时，时间就会成为nm**

```c++
const int N = 1e5 + 10, M = 2e5 + 10;
int n, m;
int idx, ne[M], e[M], h[N], w[M];
int dist[M];
bool st[N];
void add(int a, int b, int c) {
	e[++idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx;
}
int spfa() {
	memset(dist, 0x3f, sizeof dist);
	dist[1] = 0;
	queue <int> q;
	q.push(1);
	st[1] = true;
	while (q.size()) {
		auto t = q.front();
		q.pop();
		st[t] = false;
		for (int i = h[t]; i != -1; i = ne[i]) {
			int j = e[i];
			if (dist[j] > dist[t] + w[i]) { // 只将会松弛后的点入队
				dist[j] = dist[t] + w[i];
				if (!st[j]) {
					q.push(j);
					st[j] = true; // 防止重复入队
				}
			}
		}
	}
	return dist[n];
}
```

**SPFA也可以判断负权环（根据抽屉原理）， 加上cnt[n]数组即可**

代码如下：

```c++
bool spfa() {
	memset(dist, 0x3f, sizeof dist);
	dist[1] = 0;
	queue <int> q;
	q.push(1);
	st[1] = true;
	while (q.size()) {
		int t = q.front();
		q.pop();
		st[t] = false;
		for (int i = h[t]; i != -1; i = ne[i]) {
			int j = e[i];
			if (dist[j] > dist[t] + w[i]) {
				dist[j] = dist[t] + w[i];
				cnt[j] += 1;
				if (cnt[j] > n - 1) return true;
				if (!st[j]) {
					st[j] = true;
					q.push(j);
				}	
			}
		}
	}
	return false;
}
```



**你果然坚持下来了，去吧！最后一个算法超级简单的哦！这是最勇者的馈赠！**

**勇气是人类的赞歌，人类的伟大是勇气的伟大！**

#### Floyd

```c++
void floyd()
{
    for (int k = 1; k <= n; k ++ )
        for (int i = 1; i <= n; i ++ )
            for (int j = 1; j <= n; j ++ )
                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
}
```



