## 3.1.3 有向图的拓扑序列

*2025年5月17日*

- **拓扑序列：**

拓扑序列是有向无环图中顶点的线性排列，对于图中每条有向边\((u, v)\) ，在序列里u排在v前，用于确定有先后依赖关系元素的顺序，可借助 BFS、DFS 算法求解。

- **入度：**

有向图中顶点的入度指指向该顶点的边的数量，在拓扑排序中常从入度为 0 的顶点开始处理，体现顶点作为终点被关联的情况。

- **出度：**

有向图里顶点的出度是从该顶点出发的边的数量，和入度共同反映顶点与其他顶点连接的情况，二者之和为顶点度数。

#### 题目描述

给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环。

请输出任意一个该有向图的拓扑序列，如果拓扑序列不存在，则输出 -1 。

若一个由图中所有点构成的序列 A 满足：对于图中的每条边 \((x, y)\)，x 在 A 中都出现在 y 之前，则称 A 是该图的一个拓扑序列。

#### 输入格式

第一行包含两个整数 n 和 m 。

接下来 m 行，每行包含两个整数 x 和 y ，表示点 x 和点 y 之间存在一条有向边 \((x, y)\) 。

#### 输出格式

共一行，如果存在拓扑序列，则输出拓扑序列。

否则输出 -1 。

#### 数据范围

$(1 \leq n, m \leq 10^5)$

#### 输入样例

```plaintext
4 3
1 2
2 3
1 4
```

#### 输出样例

```plaintext
1 2 3 4
```

#### 代码范例

```c++
#include <iostream>
#include <cstring>

using namespace std;

const int N = 1e5 + 10;
int n, m;
int idx, e[N], ne[N], h[N], d[N]; // d[N] 表示入度
int q[N];

void add(int a, int b) {
	e[++idx] = b, ne[idx] = h[a], h[a] = idx, d[b] ++;
}

bool topsort() {
	int tt = 0, hh = 0;
	for (int i = 1; i <= n; i++)
		if (!d[i]) q[tt++] = i;
	while (hh <= tt) {
		int t = q[hh++];
		for (int i = h[t]; i != -1; i = ne[i]) {
			int j = e[i];
			d[j] --;
			if (!d[j]) q[tt++] = j;
		}
	}
	return tt == n;
}
int main() {
	cin >> n >> m;
	memset(h, -1, sizeof h);
	while (m--) {
		int a, b;
		cin >> a >> b;
		add(a, b);
	}
	if (topsort()) 
		for (int i = 0; i < n; i++) cout << q[i] << ' ';
	else puts("-1");		
	return 0;
}
```

