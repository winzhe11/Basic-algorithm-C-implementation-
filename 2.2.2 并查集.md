## 2.2.2 并查集

*5月1日*

### 题目：集合操作

#### 题目描述

一共有 `n` 个物品，编号是 `1~n`，最开始每个物品各自在一个集合中。 现在要进行 `m` 个操作，操作共有两种：

1. “C a b”，将编号为 `a` 和 `b` 的两个物品所在的集合合并，如果两个物品已经在同一个集合中，则忽略这个操作；
2. “S a b”，询问编号为 `a` 和 `b` 的两个物品是否在同一个集合中。

#### 输入格式

第一行输入整数 `n` 和 `m`。 接下来 `m` 行，每行包含一个操作指令，指令为 “C a b” 或 “S a b” 中的一种。

#### 输出格式

对于每个询问指令 “S a b”，都要输出一个结果，如果 `a` 和 `b` 在同一集合内，则输出 “Yes”，否则输出 “No”。每个结果占一行。

#### 数据范围

\(1 ≤ n, m ≤ 10^5\)

#### 输入样例

```plaintext
5 3
C 1 2
S 1 2
S 3 4
```

#### 输出样例

```plaintext
Yes
No
```

### 代码

```c++
#include <iostream>

using namespace std;

const int N = 1e5 + 10;
int p[N];

int find(int x) {
	if (x != p[x])
		p[x] = find(p[x]);
	return p[x];
}

int main() {
	int n, m;
	cin >> n >> m;
	for (int i = 1; i <= n; i++)
		p[i] = i;
	while (m--) {
		char op;
		int a, b;
		cin >> op >> a >> b;
		if (op == 'C')
			p[find(a)] = find(b);
		else {
			if (find(a) == find(b))
				puts("Yes");
			else
				puts("No");
		}
	}
	return 0;
}
```

这段 C++ 代码实现了一个并查集（Union-Find）数据结构，用于处理不相交集合的合并与查询问题。并查集的核心功能包括：

1. **路径压缩优化的查找操作**：

   ```cpp
   int find(int x) {
       if (x != p[x])
           p[x] = find(p[x]);  // 路径压缩，将节点直接连接到根节点
       return p[x];
   }
   ```

   - 递归查找节点的根节点
   - 路径压缩确保后续查询效率为 O (1)

2. **集合合并操作**：

   ```cpp
   if (op == 'C')
       p[find(a)] = find(b);  // 将a的根节点合并到b的根节点
   ```

   - 通过查找两个元素的根节点并合并

3. **连通性查询**：

   ```cpp
   if (find(a) == find(b))
       puts("Yes");
   else
       puts("No");
   ```

   - 判断两个元素是否属于同一集合

**代码特点**：

- **初始化**：每个元素的父节点初始化为自身（`p[i] = i`）
- **路径压缩**：通过递归实现路径压缩，提高查询效率
- **高效性**：处理 m 次操作的时间复杂度接近 O (m)

**应用场景**：

- 连通性问题（如网络连接、图的连通分量）
- 动态连通性维护
- 等价类划分