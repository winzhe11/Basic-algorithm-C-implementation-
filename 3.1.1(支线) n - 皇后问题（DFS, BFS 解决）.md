### 3.1.1(支线) n - 皇后问题（DFS, BFS 解决）

*2025年5月17日*

![](./../photo/n皇后.png)

**DFS**

```c++
#include <iostream>

using namespace std;

const int N = 100;
char str[N][N];
int n;
bool col[N], dg[N], udg[N]; 

void dfs(int u, int x) {
	if (u == n) {
		for (int i = 0; i < n; i++) {
			puts(str[i]);
			puts("");
		}
		return ;
	}
	for (int i = 0; i < n; i++) {
		if (!col[i] && !dg[x + i] && !udg[x + n - i]) {
			col[i] = dg[x + i] = udg[x + n - i] = true; // 这里对角线方程可以把矩阵建系后得到
			str[x][i] = 'Q';
			dfs(u + 1, x + 1);
			col[i] = dg[x + i] = udg[x + n - i] = false;
			str[x][i] = '.';
		}
	}
}
int main() {
	cin >> n;
	for (int i = 0; i < n; i++)
		for (int j = 0; j < n; j++)
			str[i][j] = '.';
	dfs(0, 0);	
	return 0;
}
```

**BFS**

```c++
#include <iostream>

using namespace std;

const int N = 100;
int n;
char str[N][N];
bool row[N], col[N], dg[N], udg[N];

void bfs(int x, int y, int u) {
	if (y == n) x++, y = 0;
	if (x == n) {
		if (u == n) 
			for (int i = 0; i < n; i++) {
				puts(str[i]);
				puts("");
			}
		return ;	
	}
	if (!row[x] && !col[y] && !dg[x + y] && !udg[x + n - y]) {
		row[x] = col[y] = dg[x + y] = udg[x + n - y] = true;
		str[x][y] = 'Q';
		bfs(x, y +, u + 1);
		row[x] = col[y] = dg[x + y] = udg[x + n - y] = false;
		str[x][y] = '.';
	}
	bfs(x, y + 1, u);
}

int main() {
	cin >> n;
	for (int i = 0; i < n; i++)
		for (int j = 0; j < n; j++)
			str[i][j] = '.';
	bfs(0, 0, 0);	
	return 0;
}
```

