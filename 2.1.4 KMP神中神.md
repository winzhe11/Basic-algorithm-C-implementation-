## 2.1.4 KMP神中神

*4月29日*

### 题目：字符串匹配

#### 题目描述

给定两个字符串 `A` 和 `B`，其中 `A` 的长度为 `N`，`B` 的长度为 `M`。请使用 KMP 算法在字符串 `A` 中查找字符串 `B` 所有出现的位置（位置从 0 开始计数），如果字符串 `B` 没有在字符串 `A` 中出现，则输出 `“-1”`（不包含引号）。

#### 输入格式

第一行包含一个整数 `N`，表示字符串 `A` 的长度。
第二行输入字符串 `A`，字符串 `A` 由小写英文字母组成。
第三行包含一个整数 `M`，表示字符串 `B` 的长度。
第四行输入字符串 `B`，字符串 `B` 由小写英文字母组成。

#### 输出格式

输出若干个整数，按照从小到大的顺序依次表示字符串 `B` 在字符串 `A` 中出现的位置，每个位置占一行。如果字符串 `B` 没有在字符串 `A` 中出现，则输出 `“-1”`（不包含引号）。

#### 数据范围

- `1 ≤ N ≤ 10⁶`

- `1 ≤ M ≤ 10⁵`

- 字符串 `A` 和 `B` 均由小写英文字母组成

  #### 输入样例

  ```plaintext
  12
  abababababab
  6
  ababab
  ```

  #### 输出样例

  ```plaintext
  0
  2
  4
  6
  ```

  

#### 代码

```c++
#include <iostream>

using namespace std;

const int N = 1e6 + 10;
char p[N], s[N];
int ne[N];

int main() {
	int n, m;
	cin >> n >> (s + 1) >> m >> (p + 1);
	// 建立next数组
	for (int i = 2, j = 0; i <= m; i++) {
		while (j && p[j + 1] != p[i])
			j = ne[j];
		if (p[j + 1] == p[i])
			j++;
		ne[i] = j;
	}
	// KMP
	for (int i = 1, j = 0; i <= n; i++) {
		while (j && p[j + 1] != s[i])
			j = ne[j];
		if (p[j + 1] == s[i])
			j++;
		if (j == m) {
			cout << i - m << endl;
			j = ne[j];
		}
	}
	return 0;
}
```

