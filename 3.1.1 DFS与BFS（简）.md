## 3.1.1 DFS与BFS（简）

*2025年5月17日*

### DFS

#### 描述

给定一个整数n，将数字1—n排成一排，输出所有可能的排列方法，按字典序排列。

#### 输入格式

一个整数n（1 ≤ n ≤ 9）

#### 输出格式

每行一个排列，数字间用空格分隔

#### 示例

输入：

```
3
```

输出：

```
1 2 3
1 3 2
2 1 3
2 3 1
3 1 2
3 2 1
```

#### 代码

```c++
#include <iostream>

using namespace std;

const int N = 1e5 + 10;
int n, a[N];
bool st[N];

void dfs(int u) {
	if (u == n) {
		for (int i = 0; i < n; i++) cout << a[i] << ' ';
		puts("");
		return ;	
	}
	for (int i = 1; i <= n; i++) {
		if (!st[i]) {
			st[i] = true;
			a[u] = i;
			dfs(u + 1);
			st[i] = false;
		}
	}
}

int main() {
	cin >> n;
	dfs(0);
	return 0;
}
```

### BFS

### 题目描述

给定一个 \(n \times m\) 的二维整数数组，用于表示一个迷宫。数组中仅包含 0 或 1 ，其中 0 代表可以通行的路径，1 代表无法通过的墙壁。

最初，有一个人位于左上角 \((1, 1)\) 处，已知此人每次能够向上、下、左、右任意一个方向移动一个位置。

请计算，此人从左上角移动至右下角 \((n, m)\) 处，最少需要移动多少次。

数据保证左上角 \((1, 1)\) 处和右下角 \((n, m)\) 处的数字为 0 ，且一定至少存在一条通路。

### 输入格式

第一行包含两个整数 n 和 m 。

接下来 n 行，每行包含 m 个整数（0 或 1 ），表示完整的二维数组迷宫。

### 输出格式

输出一个整数，表示从左上角移动至右下角的最少移动次数。

### 数据范围

$(1 \leq n, m \leq 100)$

### 输入样例

```plaintext
5 5
0 1 0 0 0
0 1 0 1 0
0 0 0 0 0
0 1 1 1 0
0 0 0 1 0
```

### 输出样例

```plaintext
8
```

### 代码

```c++
#include <iostream>
#include <utility>

using namespace std;

const int N = 110;
typedef pair<int, int> PII;
int a[N][N], d[N][N], dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0};
int n, m;
PII q[N],  query[N][N];
void bfs() {
	int tt = 0, hh = 0;
	while (hh <= tt) {
		auto t = q[hh++];
		for (int i = 0; i < 4; i++) {
			int x = t.first + dx[i], y = t.second + dy[i];
			if (x >= 0 && x < n && y >= 0 && y < m && !a[x][y] && !d[x][y]) {
				d[x][y] = d[t.first][t.second] + 1;
				query[x][y] = t;
				q[++tt] = {x, y};
			}
		}
	}
	int x = n - 1, y = m - 1;
	while (x || y) {
		printf("(%d, %d) -> ", x, y);
		auto t = query[x][y];
		x = t.first, y = t.second;
	}
	cout << endl << "*******************************" << endl;
}
int main() {
	cin >> n >> m;
	for (int i = 0; i < n; i++)
		for (int j = 0; j < m; j++)
			cin >> a[i][j];
	bfs();	
	cout << d[n - 1][m - 1] << endl;	
	return 0;
}
```

