## 2.1.1 数组实现链表

*4月27日*

### 单链表

#### 题目描述

实现一个单链表，链表初始为空，支持三种操作：

1. 向链表头插入一个数；
2. 删除第 `k` 个插入的数后面的数；
3. 在第 `k` 个插入的数后插入一个数。

现在要对该链表进行 `M` 次操作，进行完所有操作后，从头到尾输出整个链表。

注意：题目中第 `k` 个插入的数并不是指当前链表的第 `k` 个数。例如操作过程中一共插入了 `n` 个数，则按照插入的时间顺序，这 `n` 个数依次为：第 1 个插入的数，第 2 个插入的数，... 第 `n` 个插入的数。

#### 输入格式

第一行包含整数 `M`，表示操作次数。

接下来 `M` 行，每行包含一个操作命令，操作命令可能为以下几种：

1. `"H x"`，表示向链表头插入一个数 `x`。
2. `"D k"`，表示删除第 `k` 个输入的数后面的数（当 `k` 为 0 时，表示删除头结点）。
3. `"I k x"`，表示在第 `k` 个输入的数后面插入一个数 `x`（此操作中 `k` 均大于 0）。

#### 输出格式

共一行，将整个链表从头到尾输出。

#### 数据范围

- `1 ≤ M ≤ 100000`
- 所有操作保证合法。

#### 输入样例

```plaintext
10
H 9
I 1 1
D 1
D 0
H 6
I 3 6
I 4 5
I 4 5
I 3 4
D 6
```

#### 输出样例

```plaintext
6 4 6 5
```

#### 代码

```c++
#include <iostream>

using namespace std;

const int N = 1e5 + 10;
int head, ne[N], e[N], idx;

void init() {
	head = -1;
	idx = 1;
}

void to_insert_head(int x) {
	e[idx] = x;
	ne[idx] = head;
	head = idx++;
}

void insert(int k, int x) {
	e[idx] = x;
	ne[idx] = ne[k];
	ne[k] = idx++;
}

void remove(int k) {
	ne[k] = ne[ne[k]];
}

int main() {
	int M;
	cin >> M;
	init();
	while (M--) {
		int k, x;
		char op;
		cin >> op;
		if (op == 'H') {
			cin >> x;
			to_insert_head(x);
		} else if (op == 'D') {
			cin >> k;
			if (k == 0)
				head = ne[head];
			else
				remove(k);
		} else if (op == 'I') {
			cin >> k >> x;
			insert(k, x);
		}
	}
	for (int i = head; i != -1; i = ne[i])
		cout << e[i] << ' ';
	return 0;
}

```

- **head**表示头节点下标
- **idx**表示当前储存到了哪个点
- **e[i]**表示节点**i**的值
- **ne[i]**表示节点**i**的指针

### 双链表

#### 题目描述

实现一个双链表，链表初始为空，支持五种操作：

1. 在链表头插入一个数；
2. 在链表尾插入一个数；
3. 删除第 `k` 个插入的数对应的节点；
4. 在第 `k` 个插入的数对应的节点前面插入一个数；
5. 在第 `k` 个插入的数对应的节点后面插入一个数。

现在要对该链表进行 `M` 次操作，进行完所有操作后，从头到尾输出整个链表。

注意：题目中第 `k` 个插入的数并不是指当前链表的第 `k` 个数。例如操作过程中一共插入了 `n` 个数，则按照插入的时间顺序，这 `n` 个数依次为：第 1 个插入的数，第 2 个插入的数，... 第 `n` 个插入的数。

#### 输入格式

第一行包含整数 `M`，表示操作次数。

接下来 `M` 行，每行包含一个操作命令，操作命令可能为以下几种：

1. `"H x"`，表示在链表头插入一个数 `x`。
2. `"T x"`，表示在链表尾插入一个数 `x`。
3. `"D k"`，表示删除第 `k` 个输入的数对应的节点（`k` 从 1 开始计数）。
4. `"I- k x"`，表示在第 `k` 个输入的数对应的节点前面插入一个数 `x`（此操作中 `k` 均大于 0）。
5. `"I k x"`，表示在第 `k` 个输入的数对应的节点后面插入一个数 `x`（此操作中 `k` 均大于 0）。

#### 输出格式

共一行，将整个链表从头到尾输出，数与数之间用空格隔开。

#### 数据范围

- `1 ≤ M ≤ 100000`
- 所有操作保证合法。

#### 输入样例

```plaintext
12
H 9
T 1
I 1 6
I- 1 5
D 1
D 2
H 8
T 7
I 3 4
I- 4 3
I 2 2
D 3
```

#### 输出样例

```plaintext
8 3 5 4 7
```

#### 代码

```c++
#include <iostream>

using namespace std;

const int N = 1e5 + 10;
int head, tail, idx, l[N], r[N], e[N];

void init() {
	head = -1, tail = 0;
	r[head] = tail, l[tail] = head;
	idx = 1;
}

void insert_to_head (int x) {
	e[idx] = x;
	l[idx] = head, r[idx] = r[head];
	l[r[head]] = idx, r[head] = idx++;
}

void insert_to_tail (int x) {
	e[idx] = x;
	l[idx] = l[tail], r[idx] = tail;
	r[l[tail]] = idx, l[tail] = idx++;
}

void insert(int k, int x) {
	e[idx] = x;
	l[idx] = k, r[idx] = r[k];
	l[r[k]] = idx, r[k] = idx++;
}

void remove(int k) {
	r[l[k]] = r[k];
	l[r[k]] = l[k];
}

int main() {
	int M;
	cin >> M;
	init();
	while (M--) {
		int k, x;
		string op;
		cin >> op;
		if (op == "H") {
			cin >> x;
			insert_to_head(x);
		} else if (op == "T") {
			cin >> x;
			insert_to_tail(x);
		} else if (op == "D") {
			cin >> k;
			remove(k);
		} else if (op == "I-") {
			cin >> k >> x;
			insert(l[k], x);
		} else if (op == "I") {
			cin >> k >> x;
			insert(k, x);
		}
	}
	for (int i = r[head]; i != tail; i = r[i])
		cout << e[i] << ' ';
	return 0;
}

```

