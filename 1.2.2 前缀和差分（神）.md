## 1.2.2 前缀和差分（神）

*2024年4月20日*

### 一维数组前缀和

#### 题目描述

输入一个长度为 n 的整数序列。
接下来再输入 m 个询问，每个询问输入一对 l, r。
对于每个询问，输出原序列中从第 l 个数到第 r 个数的和。

#### 输入格式

- 第一行包含两个整数 n 和 m。
- 第二行包含 n 个整数，表示整数数列。
- 接下来 m 行，每行包含两个整数 l 和 r，表示一个询问的区间范围。

#### 输出格式

共 m 行，每行输出一个询问的结果。

#### 数据范围

- 1≤*l*≤*r*≤*n*
- 1≤*n*,*m*≤100000
- −1000≤ 数列中元素的值 ≤1000

#### 输入样例

```plaintext
5 3
2 1 3 6 4
1 2
1 3 
2 4
```

#### 代码

```c++
#include <iostream>
using namespace std;
const int N = 100010;
int a[N], s[N], n, m;
int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n ; i++) scanf("%d", &a[i]);
    for (int i = 1; i <= n ; i++) s[i] = s[i - 1] + a[i];
    while (m--) {
        int l, r;
        scanf("%d%d", &l, &r);
        printf ("%d\n", s[r] - s[l - 1]);
    }
    return 0;
}
```



### 二维数组前缀和

#### 题目描述

给定一个 \(n \times m\) 的整数矩阵 matrix 。 接下来有 q 个询问，每个询问给出一个子矩阵的左上角坐标 \((x_1, y_1)\) 和右下角坐标 \((x_2, y_2)\) 。 对于每个询问，需要输出对应子矩阵中所有元素的和。

#### 输入格式

- 第一行包含三个整数 n，m，q，分别表示矩阵的行数、列数和询问的数量。
- 接下来 n 行，每行包含 m 个整数，描述矩阵 matrix 。
- 再接下来 q 行，每行包含四个整数 \(x_1\)，\(y_1\)，\(x_2\)，\(y_2\)，表示一个询问的子矩阵的左上角和右下角坐标 。

#### 输出格式

共 q 行，每行输出一个询问的子矩阵元素和。

#### 数据范围

- \(1 \leq n, m \leq 1000\)
- \(1 \leq q \leq 100000\)
- \(1 \leq x_1 \leq x_2 \leq n\)
- \(1 \leq y_1 \leq y_2 \leq m\)
- \(-1000 \leq\) 矩阵中元素的值 \(\leq 1000\)

#### 输入样例

```plaintext
3 3 2
1 2 3
4 5 6
7 8 9
1 1 2 2
2 2 3 3
```

#### 代码

```c++
#include <iostream>

using namespace std;

const int N = 1010;
int n, m, q ,a[N][N], s[N][N];
int main() {
    scanf("%d%d%d", &n, &m, &q);
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            scanf("%d", &a[i][j]);
    //构造前缀和
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            s[i][j] = a[i][j] + s[i][j - 1] + s[i - 1][j] - s[i - 1][j - 1];
    while (q--) {
        int x1, y1, x2, y2;
        scanf("%d%d%d%d", &x1, &y1, &x2, &y2);
        // 计算矩阵面积的公式
        printf ("%d", s[x2][y2] - s[x1 -1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1]);
    }
    return 0;
}
```

#### 一维差分

#### 题目描述

输入一个长度为 n 的整数序列。 接下来输入 m 个操作，每个操作包含三个整数 l，r，c，表示将序列中 \([l, r]\) 之间的每个数加上 c 。 请你输出进行完所有操作后的序列。

#### 输入格式

- 第一行包含两个整数 n 和 m 。
- 第二行包含 n 个整数，表示整数序列。
- 接下来 m 行，每行包含三个整数 l，r，c ，表示一个操作。

#### 输出格式

共一行，包含 n 个整数，表示最终序列。

#### 数据范围

- \(1 \leq n, m \leq 100000\)
- \(1 \leq l \leq r \leq n\)
- \(-1000 \leq c \leq 1000\)
- \(-1000 \leq\) 整数序列中元素的值 \(\leq 1000\)

#### 输入样例

```plaintext
5 3 
1 2 2 1 2
1 3 1 
2 2 2 
4 5 1 
```



#### 输出样例

```plaintext
2 5 3 2 3
```

#### 代码

```c++
#include <iostream>

using namespace std;

const int N = 100010;
int a[N], b[N], n, m;
// 构造差分数组
void insert(int l, int r, int c) {
    b[l] += c;
    b[r + 1] -= c;
}
int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
    // 假设差分数组开始是0，0，0......被差分得到的
    for (int i = 1; i <= n; i++) insert(i, i, a[i]);
    while (m--) {
        int l, r, c;
        scanf("%d%d%d", &l, &r, &c);
        insert(l, r, c);
    }
    for (int i = 1; i <= n; i++) b[i] += b[i - 1];
    for (int i = 1; i <= n; i++) printf("%d ", b[i]);
    return 0;
}
```

### 矩阵差分问题

#### 题目描述

给定一个 \(n \times m\) 的整数矩阵 matrix 。 接下来有 q 个操作，每个操作包含五个整数 \(x_1\)，\(y_1\)，\(x_2\)，\(y_2\)，c ，表示将以 \((x_1, y_1)\) 为左上角、\((x_2, y_2)\) 为右下角的子矩阵中的每个元素都加上 c 。 请你输出进行完所有操作后的矩阵。

#### 输入格式

- 第一行包含三个整数 n，m，q ，分别表示矩阵的行数、列数和操作的数量。
- 接下来 n 行，每行包含 m 个整数，描述矩阵 matrix 。
- 再接下来 q 行，每行包含五个整数 \(x_1\)，\(y_1\)，\(x_2\)，\(y_2\)，c ，表示一个操作。

#### 输出格式

共 n 行，每行 m 个整数，表示最终的矩阵。

#### 数据范围

- $\(1 \leq n, m \leq 1000\)$
- $\(1 \leq q \leq 100000\)$$
- \(1 \leq x_1 \leq x_2 \leq n\)
- \(1 \leq y_1 \leq y_2 \leq m\)
- \(-1000 \leq c \leq 1000\)
- \(-1000 \leq\) 矩阵中元素的值 \(\leq 1000\)

#### 输入样例

```plaintext
3 3 2
1 2 3
4 5 6
7 8 9
1 1 2 2 1
2 2 3 3 2
```

#### 输出样例

```plaintext
2 3 3
5 8 8
7 10 11
```

#### 代码

```c++
#include <iostream>

using namespace std;

const int N = 1010;
int a[N][N], b[N][N], n, m, q;

void insert(int x1,int y1,int x2,int y2, int c) {
    b[x1][y1] += c;
    b[x1][y2 + 1] -= c;
    b[x2 + 1][y1] -= c;
    b[x2 + 1][y2 + 1] += c;
}
int main() {
    scanf("%d%d%d", &n, &m, &q);
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            scanf("%d", &a[i][j]);
    // 构造差分矩阵
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            insert(i, j, i, j, a[i][j]);
    while (q--) {
        int x1, y1, x2, y2, c;
        scanf("%d%d%d%d%d", &x1, &y1, &x2, &y2, &c);
        insert(x1, y1, x2, y2, c);
    }
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            b[i][j] = b[i][j] + b[i - 1][j] + b[i][j - 1] - b[i - 1][j - 1];
    for (int i =1; i <= n; i++) {
        for (int j = 1; j <= m; j++)
            printf("%d ", b[i][j]);
        printf("\n");
    }
    return 0;
}
```

