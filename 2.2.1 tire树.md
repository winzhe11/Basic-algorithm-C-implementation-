## 2.2.1 tire树

*5月1日*

### 题目：Trie 字符串统计

#### 题目描述

维护一个字符串集合，支持两种操作：

1. “I x”：向集合中插入一个字符串 x；
2. “Q x”：询问一个字符串 x 在集合中出现了多少次。

共有 N 个操作，输入的字符串总长度不超过 \(10^5\)，字符串仅包含小写英文字母。

#### 输入格式

第一行包含整数 N，表示操作数。 接下来 N 行，每行包含一个操作指令，指令为 “I x” 或 “Q x” 中的一种。

#### 输出格式

对于每个询问指令 “Q x”，都要输出一个整数作为结果，表示 x 在集合中出现的次数。每个结果占一行。

#### 数据范围

\(1 ≤ N ≤ 2 * 10^4\)

#### 输入样例

```plaintext
5
I abc
Q abc
Q ab
I ab
Q ab
```

#### 输出样例

```plaintext
1
0
1
```

#### 代码

```c++
#include <iostream>

using namespace std;

const int N = 2e4 + 10;
int son[N][26], cnt[N], idx;
char str[N];

void insert(char str[]) {
	int p = 0;
	for (int i = 0; str[i]; i++) {
		int u = str[i] - 'a';
		if (!son[p][u])
			son[p][u] = ++idx;
		p = son[p][u];
	}
	cnt[p]++;
}

int query(char str[]) {
	int p = 0;
	for (int i = 0; str[i]; i++) {
		int u = str[i] - 'a';
		if (!son[p][u])
			return 0;
		p = son[p][u];
	}
	return cnt[p];
}

int main() {
	int n;
	cin >> n;
	while (n--) {
		char op;
		cin >> op >> str;
		if (op == 'I')
			insert(str);
		else
			cout << query(str) << '\n';
	}
	return 0;
}
```

这段 C++ 代码实现了一个字典树（Trie），用于高效地存储和检索字符串。字典树的结构包含以下部分：

1. **全局变量**：
   - `son[N][26]`：存储每个节点的子节点，每个节点最多有 26 个子节点（对应 a-z）
   - `cnt[N]`：记录以某个节点结尾的字符串数量
   - `idx`：节点计数器，用于分配新节点的编号
2. **插入函数 `insert`**：
   - 遍历输入字符串的每个字符
   - 若当前字符对应的子节点不存在，则创建新节点
   - 更新指针到子节点
   - 字符串结束后，增加该节点的计数
3. **查询函数 `query`**：
   - 遍历查询字符串的每个字符
   - 若途中某个字符对应的子节点不存在，返回 0
   - 字符串结束后，返回该节点的计数
4. **主函数 `main`**：
   - 读取操作次数 `n`
   - 处理每个操作：插入（I）或查询（Q）

这个实现简洁高效，适合处理大量字符串的存储和查询场景，例如自动补全、拼写检查等功能。