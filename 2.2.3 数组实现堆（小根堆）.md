## 2.2.3 数组实现堆（小根堆）

### 题目：模拟堆操作

#### 题目描述

维护一个初始为空的集合，支持以下五种操作：

1. **插入操作** `I x`：向集合中插入一个数 `x`；
2. **查询最小值** `PM`：输出当前集合中的最小值；
3. **删除最小值** `DM`：删除当前集合中的最小值（若最小值不唯一，则删除最早插入的最小值）；
4. **删除第 k 个插入的数** `D k`：删除第 `k` 个被插入的数；
5. **修改第 k 个插入的数** `C k x`：将第 `k` 个被插入的数修改为 `x`。

现在给定 `N` 次操作，对于每个 `PM` 指令，输出当前集合的最小值。

#### 输入格式

- 第一行包含一个整数 `N`，表示操作的总数。
- 接下来的 `N` 行，每行包含一个操作指令，格式为 `I x`、`PM`、`DM`、`D k` 或 `C k x`。

#### 输出格式

对于每个 `PM` 指令，输出当前集合的最小值，每个结果占一行。

#### 数据范围

- 1≤N≤1051≤*N*≤105
- −109≤x≤109−109≤*x*≤109
- 保证所有操作合法，且 `k` 不超过当前已插入数的数量。

#### 输入样例

```
10
I -10
PM
I -10
D 1
C 2 8
I 6
PM
DM
```

#### 输出样例

```
1
-10  
2
6  
```

#### 代码

```c++
#include <iostream>
#include <cstring>

using namespace std;

const int N = 1e5;
int h[N], ph[N], hp[N], idx, si;

void down(int x) {
	int t = x;
	if (x * 2 <= si && h[x * 2] < h[t])
		t = x * 2;
	if (x * 2 + 1 <= si && h[x * 2 + 1] < h[t])
		t = x * 2 + 1;
	if (t != x) {
		swap(h[t], h[x]);
		down(t);
	}
}

void up(int x) {
	while (x / 2 && h[x / 2] > h[x]) {
		swap(h[x / 2], h[x]);
		x /= 2;
	}
}

void heap_swap(int a, int b) {
	swap(ph[hp[a]], ph[hp[b]]);
	swap(hp[a], hp[b]);
	swap(h[a], h[b]);
}

int main() {
	int n;
	cin >> n;
	while (n--) {
		char op[10];
		int k, x;
		cin >> op;
		if (!strcmp(op, "I")) {
			cin >> x;
			ph[++idx] = ++si;
			hp[si] = idx;
			h[si] = x;
			up(si);
		} else if (!strcmp(op, "PM"))
			cout << h[1] << endl;
		else if (!strcmp(op, "DM")) {
			heap_swap(1, si--);
			down(1);
		} else if (!strcmp(op, "D")) {
			cin >> k;
			heap_swap(ph[k], si--);
			down(ph[k]), up(ph[k]);
		} else if (!strcmp(op, "C")) {
			cin >> k >> x;
			h[ph[k]] = x;
			down(ph[k]), up(ph[k]);
		}
	}
	return 0;
}
```

这段 C++ 代码实现了一个带索引的最小堆（优先队列），支持插入、查询最小值、删除最小值、删除指定位置元素以及修改指定位置元素等操作。以下是对代码的详细解释：

### **数据结构与变量**

- **`h[N]`**：堆数组，存储实际元素值。
- **`ph[N]`**：位置到堆索引的映射（`ph[k]` 表示第 `k` 个插入的元素在堆中的位置）。
- **`hp[N]`**：堆索引到位置的映射（`hp[i]` 表示堆中位置 `i` 的元素是第几个插入的）。
- **`idx`**：记录插入操作的次数（用于生成唯一的 `k`）。
- **`si`**：当前堆的大小（有效元素数量）。

### **核心函数**

1. **`down(int x)`**：
   - **功能**：将堆中位置 `x` 的元素向下调整，维护最小堆性质。
   - **逻辑**：比较当前节点与其子节点的值，若子节点更小则交换，递归处理直到满足堆性质。
2. **`up(int x)`**：
   - **功能**：将堆中位置 `x` 的元素向上调整，维护最小堆性质。
   - **逻辑**：比较当前节点与其父节点的值，若父节点更大则交换，直到满足堆性质。
3. **`heap_swap(int a, int b)`**：
   - **功能**：交换堆中位置 `a` 和 `b` 的元素，并更新 `ph` 和 `hp` 的映射关系。
   - **逻辑**：先交换 `ph` 和 `hp` 的映射，再交换元素值。

### **操作实现**

1. **插入元素（`I x`）**：
   - 将新元素插入堆尾，更新 `ph` 和 `hp` 映射。
   - 调用 `up` 调整堆结构。
2. **查询最小值（`PM`）**：
   - 直接输出堆顶元素 `h[1]`。
3. **删除最小值（`DM`）**：
   - 交换堆顶与堆尾元素，减少堆大小。
   - 调用 `down(1)` 调整堆结构。
4. **删除第 `k` 个插入的元素（`D k`）**：
   - 通过 `ph[k]` 找到元素在堆中的位置，与堆尾交换。
   - 减少堆大小，调用 `down` 和 `up` 调整堆结构（两者只会执行其一）。
5. **修改第 `k` 个插入的元素（`C k x`）**：
   - 更新元素值，调用 `down` 和 `up` 调整堆结构。

### **复杂度分析**

- **插入（`I`）**：\(O(\log n)\)
- **查询最小值（`PM`）**：\(O(1)\)
- **删除最小值（`DM`）**：\(O(\log n)\)
- **删除指定元素（`D`）**：\(O(\log n)\)
- **修改指定元素（`C`）**：\(O(\log n)\)

### **注意事项**

- **索引映射**：通过 `ph` 和 `hp` 数组维护插入顺序与堆位置的双向映射，确保可以快速定位和操作指定元素。
- **堆调整**：删除或修改元素后，同时调用 `down` 和 `up` 可确保堆性质被修复（实际只会执行其中一个方向的调整）。
- **数组下标**：堆的根节点位于 `h[1]`，方便计算左右子节点（`2x` 和 `2x+1`）。



该实现通过索引映射扩展了普通堆的功能，适用于需要动态维护有序集合并支持任意位置操作的场景。

