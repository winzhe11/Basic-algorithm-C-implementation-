## 2.3.1 数组模拟哈希

#### 开链法

```c++
#include <iostream>
#include <cstring>

using namespace std;

const int N = 1e5 + 3;
int h[N], e[N], ne[N], idx;

void insert(int x) {
	int k = (x % N + N) % N;
	e[++idx] = x;
	ne[idx] = h[k];
	h[k] = idx;
}

bool query(int x) {
	int k = (x % N + N) % N;
	for (int i = h[k]; i != -1; i = ne[i])
		if (e[i] == x)
			return true;
	return false;
}

int main() {
	int n;
	cin >> n;
	memset(h, -1, sizeof h);
	while (n--) {
		char op;
		int a;
		cin >> op >> a;
		if (op == 'I')
			insert(a);
		else if (op == 'Q') {
			if (query(a))
				puts("Yes");
			else
				puts("No");
		}
	}
	return 0;
}
```

#### 开放寻址法

```c++
#include <iostream>
#include <cstring>

using namespace std;
const int N = 2e5 + 3, null = 0x3f3f3f3f;
int h[N];

int find(int x) {
	int k = (x % N + N) % N;
	while (h[k] != null && h[k] != x) {
		k++;
		if (k == N)
			k = 0;
	}
	return k;
}

int main() {
	int n;
	cin >> n;
	memset(h, 0x3f, sizeof h);
	while (n--) {
		char op;
		int a;
		cin >> op >> a;
		if (op == 'I')
			h[find(a)] = a;
		else if (op == 'Q') {
			if (h[find(a)] == null)
				puts("No");
			else
				puts("Yes");
		}
	}
	return 0;
}
```

#### 字符串哈希

字符串哈希是一种将字符串转换为一个数值（哈希值）的技术，通过比较哈希值来快速判断两个字符串是否相等。以下是对这段代码所实现的字符串哈希原理的详细介绍：

1. **哈希函数的选择**

   - 常见的字符串哈希函数是基于多项式哈希的思想。在这段代码中，使用了 `P = 131` 作为哈希基数（通常选择一个较大的质数）。

   - 对于一个字符串

      

     ```
     s = s1s2...sn
     ```

     ，它的哈希值

      

     ```
     h(s)
     ```

      

     可以通过以下公式计算：

     - \(h(s) = s_1 \times P^{n - 1} + s_2 \times P^{n - 2} + \cdots + s_{n - 1} \times P^1 + s_n \times P^0\)

   - 这里的 `s_i` 表示字符串 `s` 的第 `i` 个字符（通常会将字符转换为对应的 ASCII 码值进行计算）。

2. **前缀哈希值的预处理**

   - 为了能够快速计算任意子串的哈希值，代码中预先计算了字符串的前缀哈希值 `h[i]` 和 `P` 的幂次方 `p[i]`。
   - `p[0] = 1` 初始化 `P` 的 0 次幂为 1。
   - 通过循环 `for (int i = 1; i < n; i++) { p[i] = p[i - 1] * P; h[i] = h[i - 1] * P + str[i]; }` 计算 `P` 的幂次方 `p[i]` 和前缀哈希值 `h[i]`。
   - `h[i]` 表示字符串前 `i` 个字符的哈希值，即 \(h[i] = s_1 \times P^{i - 1} + s_2 \times P^{i - 2} + \cdots + s_{i - 1} \times P^1 + s_i \times P^0\)。

3. **子串哈希值的计算**

   - 定义了 `get` 函数来计算子串 `[l, r]` 的哈希值。
   - 根据前缀哈希值的性质，子串 `[l, r]` 的哈希值可以通过公式 `h[r] - h[l - 1] * p[r - l + 1]` 计算。
   - 这是因为 `h[r]` 是前 `r` 个字符的哈希值，`h[l - 1] * p[r - l + 1]` 相当于从 `h[r]` 中减去前 `l - 1` 个字符在 `[l, r]` 子串中的贡献，从而得到 `[l, r]` 子串的哈希值。

4. **判断字符串相等**

   - 在主函数中，通过多次调用 `get` 函数来计算两个子串的哈希值。
   - 如果两个子串的哈希值相等，那么在大概率下这两个子串是相等的（存在哈希冲突的可能性，但在合理选择哈希基数和字符串长度的情况下，冲突概率较低）。
   - 通过比较哈希值来快速判断两个子串是否相等，而不需要逐个字符比较，大大提高了效率。

```c++
#include <iostream>

using namespace std;

const int N = 100010, P = 131;

int n, m;
char str[N];
unsigned long long h[N], p[N];

unsigned long long get(int l, int r) {
	return h[r] - h[l - 1] * p[r - l + 1];
}

int main() {
	cin >> n >> m >> str + 1;
	p[0] = 1;
	for (int i = 1; i < n; i++) {
		p[i] = p[i - 1] * P;
		h[i] = h[i - 1] * P + str[i];
	}
	while (m--) {
		int l1, r1, l2, r2;
		cin >> l1 >> r1 >> l2 >> r2;
		if (get(l1, r1) == get(l2, r2))
			puts("Yes");
		else
			puts("No");
	}
	return 0;
}
```

