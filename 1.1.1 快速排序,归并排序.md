#### 1.1.1 快速排序,归并排序

*2025年4月14号*

**快速排序**

```c++
#include <iostream>

using namespace std;
const int N = 10e6 + 10;
int n, q[N];
void quick_sort(int a[], int l, int r) {
    if (l >= r) return ;
    int x = a[l], i = l - 1, j = r + 1;
    while (i < j) {
        do i++; while (a[i] < x);
        do j--; while (a[j] > x);
        if (i < j ) swap(a[i], a[j]);
    }
    quick_sort(a, l, j);
    quick_sort(a, j + 1, r);
}
int main() {
    scanf("%d", &n);
    for (int i = 0; i < n; i++) scanf("%d", &q[i]);
    quick_sort(q, 0, n - 1);
    for (int i = 0; i < n; i++) printf("%d ", q[i]);
    return 0;
}
```

**快速排序的时间为**``O(nlog n)``(平均时间)



**归并排序**

```c++
#include <iostream>

using namespace std;
const int N = 10e6 + 10;
int n, q[N], tmp[N];
void merge_sort(int a[],int l,int r) {
    if (l >= r) return ;
    int mid = l + r >> 1, i = l, j = mid + 1;
    merge_sort(a, l, mid);merge_sort(a, mid + 1, r);
    int k = 0;
    while (i <= mid && j <= r) {
        if (a[i] <= a[j]) tmp[k++] = a[i++];
        else tmp[k++] = a[j++];
    }
    while (i <= mid) tmp[k++] = a[i++];
    while (j <= r) tmp[k++] = a[j++];
    for (i = l, j = 0; i <= r; i++, j++) a[i] = tmp[j];
}
int main() {
    scanf("%d", &n);
    for (int i = 0; i < n; i++) scanf("%d", &q[i]);
    merge_sort(q, 0, n - 1);
    for (int i = 0; i < n; i++) printf("%d ", q[i]);
    return 0;
}
```

**快速选择**

题目描述

给定一个长度为 n 的整数数列，以及一个整数 k，请用快速选择算法求出数列的第 k 小的数是多少。

 输入格式

- 第一行包含两个整数 n 和 k。
- 第二行包含 n 个整数（所有整数均在 1 - 10⁹范围内），表示整数数列。

输出格式

输出一个整数，表示数列的第 k 小数。

数据范围

- 1 ≤ n ≤ 100000
- 1 ≤ k ≤ n

输入样例

```plaintext
5 3
2 4 1 5 3
```

输出样例

```plaintext
3
```

**若用传统排序再搜索，很明显会超时，可以直接用快速选择``O(n)``**

```c++
#include <iostream>
#include <vector>

using namespace std;

int quick_select(vector <int> &a, int l, int r, int c) {
    if (l >= r) return a[l];
    int x = a[l], i = l - 1, j = r + 1;
    while (i < j) {
        do i++; while (a[i] < x);
        do j--; while (a[j] > x);
        if (i < j) swap(a[i], a[j]);
    }
    int sl = j - l + 1;
    if (c <= sl) return quick_select(a, l, j, c);
    else return quick_select(a, j + 1, r, c - sl);
}
int main() {
    int n, k;
    cin >> n >> k;
    vector <int> a(n);
    for (int i = 0; i < n; i++) cin >> a[i];
    cout << quick_select(a, 0, n - 1, k);
    return 0;
}
```

**注意：**若在``main``函数中声明``vector``且使用``a[i]``法赋值时，必须初始化；**但使用``push_back()``时不用。**
